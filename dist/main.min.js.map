{"version":3,"file":"main.min.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/c-p/color-picker.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 27);\n","/*!\n * ==========================================================\n *  COLOR PICKER PLUGIN 1.4.0\n * ==========================================================\n * Author: Taufik Nurrohman <https://github.com/tovic>\n * License: MIT\n * ----------------------------------------------------------\n */\n\n(function(win, doc, NS) {\n\n    var instance = '__instance__',\n        first = 'firstChild',\n        delay = setTimeout;\n\n    function is_set(x) {\n        return typeof x !== \"undefined\";\n    }\n\n    function is_string(x) {\n        return typeof x === \"string\";\n    }\n\n    function is_object(x) {\n        return typeof x === \"object\";\n    }\n\n    function object_length(x) {\n        return Object.keys(x).length;\n    }\n\n    function edge(a, b, c) {\n        if (a < b) return b;\n        if (a > c) return c;\n        return a;\n    }\n\n    function num(i, j) {\n        return parseInt(i, j || 10);\n    }\n\n    function round(i) {\n        return Math.round(i);\n    }\n\n    // [h, s, v] ... 0 <= h, s, v <= 1\n    function HSV2RGB(a) {\n        var h = +a[0],\n            s = +a[1],\n            v = +a[2],\n            r, g, b, i, f, p, q, t;\n        i = Math.floor(h * 6);\n        f = h * 6 - i;\n        p = v * (1 - s);\n        q = v * (1 - f * s);\n        t = v * (1 - (1 - f) * s);\n        i = i || 0;\n        q = q || 0;\n        t = t || 0;\n        switch (i % 6) {\n            case 0:\n                r = v, g = t, b = p;\n                break;\n            case 1:\n                r = q, g = v, b = p;\n                break;\n            case 2:\n                r = p, g = v, b = t;\n                break;\n            case 3:\n                r = p, g = q, b = v;\n                break;\n            case 4:\n                r = t, g = p, b = v;\n                break;\n            case 5:\n                r = v, g = p, b = q;\n                break;\n        }\n        return [round(r * 255), round(g * 255), round(b * 255)];\n    }\n\n    function HSV2HEX(a) {\n        return RGB2HEX(HSV2RGB(a));\n    }\n\n    // [r, g, b] ... 0 <= r, g, b <= 255\n    function RGB2HSV(a) {\n        var r = +a[0],\n            g = +a[1],\n            b = +a[2],\n            max = Math.max(r, g, b),\n            min = Math.min(r, g, b),\n            d = max - min,\n            h, s = (max === 0 ? 0 : d / max),\n            v = max / 255;\n        switch (max) {\n            case min:\n                h = 0;\n                break;\n            case r:\n                h = (g - b) + d * (g < b ? 6 : 0);\n                h /= 6 * d;\n                break;\n            case g:\n                h = (b - r) + d * 2;\n                h /= 6 * d;\n                break;\n            case b:\n                h = (r - g) + d * 4;\n                h /= 6 * d;\n                break;\n        }\n        return [h, s, v];\n    }\n\n    function RGB2HEX(a) {\n        var s = +a[2] | (+a[1] << 8) | (+a[0] << 16);\n        s = '000000' + s.toString(16);\n        return s.slice(-6);\n    }\n\n    // rrggbb or rgb\n    function HEX2HSV(s) {\n        return RGB2HSV(HEX2RGB(s));\n    }\n\n    function HEX2RGB(s) {\n        if (s.length === 3) {\n            s = s.replace(/./g, '$&$&');\n        }\n        return [num(s[0] + s[1], 16), num(s[2] + s[3], 16), num(s[4] + s[5], 16)];\n    }\n\n    // convert range from `0` to `360` and `0` to `100` in color into range from `0` to `1`\n    function _2HSV_pri(a) {\n        return [+a[0] / 360, +a[1] / 100, +a[2] / 100];\n    }\n\n    // convert range from `0` to `1` into `0` to `360` and `0` to `100` in color\n    function _2HSV_pub(a) {\n        return [round(+a[0] * 360), round(+a[1] * 100), round(+a[2] * 100)];\n    }\n\n    // convert range from `0` to `255` in color into range from `0` to `1`\n    function _2RGB_pri(a) {\n        return [+a[0] / 255, +a[1] / 255, +a[2] / 255];\n    }\n\n    // *\n    function parse(x) {\n        if (is_object(x)) return x;\n        var rgb = /\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i.exec(x),\n            hsv = /\\s*hsv\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)\\s*$/i.exec(x),\n            hex = x[0] === '#' && x.match(/^#([\\da-f]{3}|[\\da-f]{6})$/i);\n        if (hex) {\n            return HEX2HSV(x.slice(1));\n        } else if (hsv) {\n            return _2HSV_pri([+hsv[1], +hsv[2], +hsv[3]]);\n        } else if (rgb) {\n            return RGB2HSV([+rgb[1], +rgb[2], +rgb[3]]);\n        }\n        return [0, 1, 1]; // default is red\n    }\n\n    (function($) {\n\n        // plugin version\n        $.version = '1.4.0';\n\n        // collect all instance(s)\n        $[instance] = {};\n\n        // plug to all instance(s)\n        $.each = function(fn, t) {\n            return delay(function() {\n                var ins = $[instance], i;\n                for (i in ins) {\n                    fn.call(ins[i], i, ins);\n                }\n            }, t === 0 ? 0 : (t || 1)), $;\n        };\n\n        // static method(s)\n        $.parse = parse;\n        $._HSV2RGB = HSV2RGB;\n        $._HSV2HEX = HSV2HEX;\n        $._RGB2HSV = RGB2HSV;\n        $._HEX2HSV = HEX2HSV;\n        $._HEX2RGB = function(a) {\n            return _2RGB_pri(HEX2RGB(a));\n        };\n        $.HSV2RGB = function(a) {\n            return HSV2RGB(_2HSV_pri(a));\n        };\n        $.HSV2HEX = function(a) {\n            return HSV2HEX(_2HSV_pri(a));\n        };\n        $.RGB2HSV = function(a) {\n            return _2HSV_pub(RGB2HSV(a));\n        };\n        $.RGB2HEX = RGB2HEX;\n        $.HEX2HSV = function(s) {\n            return _2HSV_pub(HEX2HSV(s));\n        };\n        $.HEX2RGB = HEX2RGB;\n\n    })(win[NS] = function(source, events, parent) {\n\n        var b = doc.body,\n            h = doc.documentElement,\n            $ = this,\n            $$ = win[NS],\n            _ = false,\n            hooks = {},\n            self = doc.createElement('div'),\n            on_down = \"touchstart mousedown\",\n            on_move = \"touchmove mousemove\",\n            on_up = \"touchend mouseup\",\n            on_resize = \"orientationchange resize\";\n\n        // return a new instance if `CP` was called without the `new` operator\n        if (!($ instanceof $$)) {\n            return new $$(source, events);\n        }\n\n        // store color picker instance to `CP.__instance__`\n        $$[instance][source.id || source.name || object_length($$[instance])] = $;\n\n        // trigger color picker panel on click by default\n        if (!is_set(events) || events === true) {\n            events = on_down;\n        }\n\n        // add event\n        function on(ev, el, fn) {\n            ev = ev.split(/\\s+/);\n            for (var i = 0, ien = ev.length; i < ien; ++i) {\n                el.addEventListener(ev[i], fn, false);\n            }\n        }\n\n        // remove event\n        function off(ev, el, fn) {\n            ev = ev.split(/\\s+/);\n            for (var i = 0, ien = ev.length; i < ien; ++i) {\n                el.removeEventListener(ev[i], fn);\n            }\n        }\n\n        // get mouse/finger coordinate\n        function point(el, e) {\n            var T = 'touches',\n                X = 'clientX',\n                Y = 'clientY',\n                x = !!e[T] ? e[T][0][X] : e[X],\n                y = !!e[T] ? e[T][0][Y] : e[Y],\n                o = offset(el);\n            return {\n                x: x - o.l,\n                y: y - o.t\n            };\n        }\n\n        // get position\n        function offset(el) {\n            var left, top, rect;\n            if (el === win) {\n                left = win.pageXOffset || h.scrollLeft;\n                top = win.pageYOffset || h.scrollTop;\n            } else {\n                rect = el.getBoundingClientRect();\n                left = rect.left;\n                top = rect.top;\n            }\n            return {\n                l: left,\n                t: top\n            };\n        }\n\n        // get closest parent\n        function closest(a, b) {\n            while ((a = a.parentElement) && a !== b);\n            return a;\n        }\n\n        // prevent default\n        function prevent(e) {\n            if (e) e.preventDefault();\n        }\n\n        // get dimension\n        function size(el) {\n            return el === win ? {\n                w: win.innerWidth,\n                h: win.innerHeight\n            } : {\n                w: el.offsetWidth,\n                h: el.offsetHeight\n            };\n        }\n\n        // get color data\n        function get_data(a) {\n            return _ || (is_set(a) ? a : false);\n        }\n\n        // set color data\n        function set_data(a) {\n            _ = a;\n        }\n\n        // add hook\n        function add(ev, fn, id) {\n            if (!is_set(ev)) return hooks;\n            if (!is_set(fn)) return hooks[ev];\n            if (!is_set(hooks[ev])) hooks[ev] = {};\n            if (!is_set(id)) id = object_length(hooks[ev]);\n            return hooks[ev][id] = fn, $;\n        }\n\n        // remove hook\n        function remove(ev, id) {\n            if (!is_set(ev)) return hooks = {}, $;\n            if (!is_set(id)) return hooks[ev] = {}, $;\n            return delete hooks[ev][id], $;\n        }\n\n        // trigger hook\n        function trigger(ev, a, id) {\n            if (!is_set(hooks[ev])) return $;\n            if (!is_set(id)) {\n                for (var i in hooks[ev]) {\n                    hooks[ev][i].apply($, a);\n                }\n            } else {\n                if (is_set(hooks[ev][id])) {\n                    hooks[ev][id].apply($, a);\n                }\n            }\n            return $;\n        }\n\n        // initialize data ...\n        set_data($$.parse(source.getAttribute('data-color') || source.value || [0, 1, 1]));\n\n        // generate color picker pane ...\n        self.className = 'color-picker';\n        self.innerHTML = '<div class=\"color-picker-container\"><span class=\"color-picker-h\"><i></i></span><span class=\"color-picker-sv\"><i></i></span></div>';\n        var c = self[first].children,\n            HSV = get_data([0, 1, 1]), // default is red\n            H = c[0],\n            SV = c[1],\n            H_point = H[first],\n            SV_point = SV[first],\n            start_H = 0,\n            start_SV = 0,\n            drag_H = 0,\n            drag_SV = 0,\n            left = 0,\n            top = 0,\n            P_W = 0,\n            P_H = 0,\n            v = HSV2HEX(HSV),\n            set;\n\n        // on update ...\n        function trigger_(k, x) {\n            if (!k || k === \"h\") {\n                trigger(\"change:h\", x);\n            }\n            if (!k || k === \"sv\") {\n                trigger(\"change:sv\", x);\n            }\n            trigger(\"change\", x);\n        }\n\n        // is visible?\n        function visible() {\n            return self.parentNode;\n        }\n\n        // create\n        function create(first, bucket) {\n            if (!first) {\n                (parent || bucket || b).appendChild(self), $.visible = true;\n            }\n            P_W = size(self).w;\n            P_H = size(self).h;\n            var SV_size = size(SV),\n                SV_point_size = size(SV_point),\n                H_H = size(H).h,\n                SV_W = SV_size.w,\n                SV_H = SV_size.h,\n                H_point_H = size(H_point).h,\n                SV_point_W = SV_point_size.w,\n                SV_point_H = SV_point_size.h;\n            if (first) {\n                self.style.left = self.style.top = '-9999px';\n                function click(e) {\n                    var t = e.target,\n                        is_source = t === source || closest(t, source) === source;\n                    if (is_source) {\n                        create();\n                    } else {\n                        $.exit();\n                    }\n                    trigger(is_source ? \"enter\" : \"exit\", [$]);\n                }\n                if (events !== false) {\n                    on(events, source, click);\n                }\n                $.create = function() {\n                    return create(1), trigger(\"create\", [$]), $;\n                };\n                $.destroy = function() {\n                    if (events !== false) {\n                        off(events, source, click);\n                    }\n                    $.exit(), set_data(false);\n                    return trigger(\"destroy\", [$]), $;\n                };\n            } else {\n                fit();\n            }\n            set = function() {\n                HSV = get_data(HSV), color();\n                H_point.style.top = (H_H - (H_point_H / 2) - (H_H * +HSV[0])) + 'px';\n                SV_point.style.right = (SV_W - (SV_point_W / 2) - (SV_W * +HSV[1])) + 'px';\n                SV_point.style.top = (SV_H - (SV_point_H / 2) - (SV_H * +HSV[2])) + 'px';\n            };\n            $.exit = function(e) {\n                if (visible()) {\n                    visible().removeChild(self);\n                    $.visible = false;\n                }\n                off(on_down, H, down_H);\n                off(on_down, SV, down_SV);\n                off(on_move, doc, move);\n                off(on_up, doc, stop);\n                off(on_resize, win, fit);\n                return $;\n            };\n            function color(e) {\n                var a = HSV2RGB(HSV),\n                    b = HSV2RGB([HSV[0], 1, 1]);\n                SV.style.backgroundColor = 'rgb(' + b.join(',') + ')';\n                set_data(HSV);\n                prevent(e);\n            };\n            set();\n            function do_H(e) {\n                var y = edge(point(H, e).y, 0, H_H);\n                HSV[0] = (H_H - y) / H_H;\n                H_point.style.top = (y - (H_point_H / 2)) + 'px';\n                color(e);\n            }\n            function do_SV(e) {\n                var o = point(SV, e),\n                    x = edge(o.x, 0, SV_W),\n                    y = edge(o.y, 0, SV_H);\n                HSV[1] = 1 - ((SV_W - x) / SV_W);\n                HSV[2] = (SV_H - y) / SV_H;\n                SV_point.style.right = (SV_W - x - (SV_point_W / 2)) + 'px';\n                SV_point.style.top = (y - (SV_point_H / 2)) + 'px';\n                color(e);\n            }\n            function move(e) {\n                if (drag_H) {\n                    do_H(e), v = HSV2HEX(HSV);\n                    if (!start_H) {\n                        trigger(\"drag:h\", [v, $]);\n                        trigger(\"drag\", [v, $]);\n                        trigger_(\"h\", [v, $]);\n                    }\n                }\n                if (drag_SV) {\n                    do_SV(e), v = HSV2HEX(HSV);\n                    if (!start_SV) {\n                        trigger(\"drag:sv\", [v, $]);\n                        trigger(\"drag\", [v, $]);\n                        trigger_(\"sv\", [v, $]);\n                    }\n                }\n                start_H = 0,\n                start_SV = 0;\n            }\n            function stop(e) {\n                var t = e.target,\n                    k = drag_H ? \"h\" : \"sv\",\n                    a = [HSV2HEX(HSV), $],\n                    is_source = t === source || closest(t, source) === source,\n                    is_self = t === self || closest(t, self) === self;\n                if (!is_source && !is_self) {\n                    // click outside the source or picker element to exit\n                    if (visible() && events !== false) $.exit(), trigger(\"exit\", [$]), trigger_(0, a);\n                } else {\n                    if (is_self) {\n                        trigger(\"stop:\" + k, a);\n                        trigger(\"stop\", a);\n                        trigger_(k, a);\n                    }\n                }\n                drag_H = 0,\n                drag_SV = 0;\n            }\n            function down_H(e) {\n                start_H = 1,\n                drag_H = 1,\n                move(e), prevent(e);\n                trigger(\"start:h\", [v, $]);\n                trigger(\"start\", [v, $]);\n                trigger_(\"h\", [v, $]);\n            }\n            function down_SV(e) {\n                start_SV = 1,\n                drag_SV = 1,\n                move(e), prevent(e);\n                trigger(\"start:sv\", [v, $]);\n                trigger(\"start\", [v, $]);\n                trigger_(\"sv\", [v, $]);\n            }\n            if (!first) {\n                on(on_down, H, down_H);\n                on(on_down, SV, down_SV);\n                on(on_move, doc, move);\n                on(on_up, doc, stop);\n                on(on_resize, win, fit);\n            }\n        } create(1);\n\n        delay(function() {\n            var a = [HSV2HEX(HSV), $];\n            trigger(\"create\", a);\n            trigger_(0, a);\n        }, 0);\n\n        // fit to window\n        $.fit = function(o) {\n            var w = size(win),\n                y = size(h),\n                screen_w = w.w - y.w, // vertical scroll bar\n                screen_h = w.h - h.clientHeight, // horizontal scroll bar\n                ww = offset(win),\n                to = offset(source);\n            left = to.l + ww.l;\n            top = to.t + ww.t + size(source).h; // drop!\n            if (is_object(o)) {\n                is_set(o[0]) && (left = o[0]);\n                is_set(o[1]) && (top = o[1]);\n            } else {\n                var min_x = ww.l,\n                    min_y = ww.t,\n                    max_x = ww.l + w.w - P_W - screen_w,\n                    max_y = ww.t + w.h - P_H - screen_h;\n                left = edge(left, min_x, max_x) >> 0;\n                top = edge(top, min_y, max_y) >> 0;\n            }\n            self.style.left = left + 'px';\n            self.style.top = top + 'px';\n            return trigger(\"fit\", [$]), $;\n        };\n\n        // for event listener ID\n        function fit() {\n            return $.fit();\n        }\n\n        // set hidden color picker data\n        $.set = function(a) {\n            if (!is_set(a)) return get_data();\n            if (is_string(a)) {\n                a = $$.parse(a);\n            }\n            return set_data(a), set(), $;\n        };\n\n        // alias for `$.set()`\n        $.get = function(a) {\n            return get_data(a);\n        };\n\n        // register to global ...\n        $.source = source;\n        $.self = self;\n        $.visible = false;\n        $.on = add;\n        $.off = remove;\n        $.fire = trigger;\n        $.hooks = hooks;\n        $.enter = function(bucket) {\n            return create(0, bucket);\n        };\n\n        // return the global object\n        return $;\n\n    });\n\n})(window, document, 'CP');"],"mappings":"AACA;;;;;;;;;ACQA","sourceRoot":""}